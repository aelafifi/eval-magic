# API Documentation

## `compile` Function

The `compile` function is the core functionality of eval-magic that parses, transforms, and prepares JavaScript code for execution with enhanced features like operator overloading, custom imports, and export handling.

### Signature

```typescript
function compile(
  code: string,
  globals?: Record<string, any>,
  options?: RunOptions
): CompiledCode
```

### Parameters

#### `code: string`
The JavaScript code to compile. This can include:
- Standard JavaScript syntax
- Export statements (when `options.returns` is "exports")
- Import statements (when `options.importFunction` is provided)
- Operator overloading expressions (when `options.operatorOverloading` is enabled)

#### `globals?: Record<string, any>` (optional)
An object containing variables and functions to make available in the code's execution scope. Only identifiers that are actually referenced in the code will be included in the final scope for security and performance.

**Default:** `{}`

#### `options?: RunOptions` (optional)
Configuration options for parsing, transforming, and executing the code.

**Default:** 
```typescript
{
  parseOptions: { ecmaVersion: "latest" },
  codegenOptions: {},
  returns: "exports",
  operatorOverloading: true,
  customVisitors: {},
  isAsync: false
}
```

**Properties:**

- **`parseOptions?: Partial<acorn.Options>`**
  
  Options passed to the Acorn parser. 
  
  **Default:**
  ```typescript
  {
    ecmaVersion: "latest",
    sourceType: "module", // when options.returns === "exports"
    allowReturnOutsideFunction: true // when options.returns === "return"
  }
  ```

- **`codegenOptions?: escodegen.GenerateOptions`**
  
  Options passed to Escodegen for code generation from the transformed AST.

- **`returns?: "exports" | "return"`**
  
  Defines how the code should handle return values:
  - `"exports"` (default): Use export statements to return values, enables modular code patterns
  - `"return"`: Use standard JavaScript return statements
  
- **`operatorOverloading?: boolean`**
  
  Enables Python-like operator overloading via magic methods using the `Py` symbols.
  
  **Default:** `true`

- **`customVisitors?: Record<string, VisitorFn>`**
  
  Custom AST visitor functions for additional transformations during the compilation process.
  
  **Note:** This property is not currently defined in the TypeScript interface but is used in the implementation.

- **`importFunction?: (source: string) => Object | Promise<Object>`**
  
  Custom import handler for resolving module imports. Can be synchronous or asynchronous.
  
  **Note:** If an async function is provided, `options.isAsync` will automatically be set to `true`.

- **`isAsync?: boolean`**
  
  Wraps the generated code in an async function, enabling top-level await usage.
  
  **Default:** `false`

### Return Value

Returns a `CompiledCode` object with the following properties:

```typescript
interface CompiledCode {
  origCode: string;    // The original input code
  genCode: string;     // The generated/transformed JavaScript code
  fn: Function;        // The compiled function ready for execution
  args: any[];         // The arguments array to pass to the function
  run: () => any;      // Convenience method to execute the compiled code
}
```

#### Properties

- **`origCode: string`** - The original input code passed to the compile function
- **`genCode: string`** - The transformed JavaScript code generated by eval-magic
- **`fn: Function`** - The compiled function ready for execution
- **`args: any[]`** - The array of arguments that will be passed to the function when executed
- **`run: () => any`** - A convenience method that executes the compiled function with the prepared arguments

## Usage Examples

### Basic Compilation

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `export const result = x + y;`,
  { x: 10, y: 20 }
);

console.log(compiled.origCode);  // `export const result = x + y;`
console.log(compiled.genCode);   // Generated JavaScript code
console.log(compiled.run());     // { result: 30 }
```

### Using Return Instead of Export

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `return x * 2;`,
  { x: 15 },
  { returns: "return" }
);

console.log(compiled.run()); // 30
```

### Working with Complex Expressions

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const doubled = x * 2;
  const squared = doubled ** 2;
  export const result = squared + offset;
  `,
  { x: 5, offset: 10 }
);

console.log(compiled.run()); // { result: 110 }
```

### Operator Overloading

```javascript
import { compile, Py } from "eval-magic";

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  [Py.__add__](other) {
    return new Point(this.x + other.x, this.y + other.y);
  }

  toString() {
    return `Point(${this.x}, ${this.y})`;
  }
}

const compiled = compile(
  `export const result = p1 + p2;`,
  {
    p1: new Point(1, 2),
    p2: new Point(3, 4)
  }
);

const result = compiled.run();
console.log(result.result.toString()); // Point(4, 6)
```

### Async Code with Top-Level Await

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
  await delay(100);
  export const result = "Async operation completed";
  `,
  { setTimeout: global.setTimeout },
  { isAsync: true }
);

// Note: run() returns a Promise when isAsync is true
const result = await compiled.run();
console.log(result); // { result: "Async operation completed" }
```

### Advanced Configuration

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const helper = (x) => x * 2;
  export const computed = helper(data) ** 2;
  `,
  { data: 5 },
  {
    parseOptions: {
      ecmaVersion: 2020,
      sourceType: "module"
    },
    codegenOptions: {
      format: {
        indent: {
          style: "  "
        }
      }
    },
    returns: "exports",
    operatorOverloading: true,
    isAsync: false
  }
);

const result = compiled.run();
console.log(result); // { computed: 100 }
```

## Integration with `evaluate`

The `compile` function is used internally by the `evaluate` function. You can use `compile` when you need more control over the execution process or want to reuse the compiled code multiple times:

```javascript
import { compile, evaluate } from "eval-magic";

// Using evaluate (simple, one-time execution)
const result1 = evaluate(
  `export const sum = a + b;`,
  { a: 1, b: 2 }
);

// Using compile (more control, reusable)
const compiled = compile(
  `export const sum = a + b;`,
  { a: 1, b: 2 }
);

const result2 = compiled.run();
const result3 = compiled.run(); // Can reuse the compiled function

// Both approaches yield the same result
console.log(result1); // { sum: 3 }
console.log(result2); // { sum: 3 }
```

## Error Handling

The `compile` function may throw errors during various phases:

### Parse Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(`invalid javascript syntax {`);
} catch (error) {
  console.error("Parse error:", error.message);
  // Handle syntax errors in the input code
}
```

### Transform Errors

```javascript
import { compile } from "eval-magic";

// Currently, there's a bug in import function validation
// This will throw an error even with a valid importFunction
try {
  const compiled = compile(
    `import { unknown } from "missing-module";`,
    {},
    {
      importFunction: (source) => {
        throw new Error(`Module not found: ${source}`);
      }
    }
  );
  
  compiled.run();
} catch (error) {
  console.error("Import error:", error.message);
  // Will show: "import statement is not allowed without an importFunction"
}
```

### Configuration Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(
    `export const result = x;`,
    { x: 42 },
    {
      parseOptions: {
        ecmaVersion: 3 // Very old version might cause issues
      }
    }
  );
} catch (error) {
  console.error("Configuration error:", error.message);
}
```

## Performance Considerations

- **Scope Filtering**: Only variables from `globals` that are actually referenced in the code are included in the execution scope
- **Reusability**: Compiled functions can be executed multiple times without recompilation
- **Async Overhead**: Setting `isAsync: true` adds async function wrapper overhead

```javascript
import { compile } from "eval-magic";

// Compile once, run multiple times for better performance
const compiled = compile(
  `export const result = input * 2;`,
  { input: 0 } // Placeholder, will be filtered out
);

// This is more efficient than calling evaluate() multiple times
const results = [1, 2, 3, 4, 5].map(num => {
  // Note: You'd need to modify the approach for different inputs
  // This example shows the concept of reusability
  return compiled.run();
});
```

For different inputs, you would typically use parameter passing or recompile with new globals as needed.

## Related Functions

- **[`evaluate`](README.md#usage)**: Higher-level function that compiles and immediately executes code
- **[`Py` operators](README.md#example)**: Magic method symbols for operator overloading