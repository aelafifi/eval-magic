# API Documentation

## `compile` Function

The `compile` function is the core functionality of eval-magic that parses, transforms, and prepares JavaScript code for execution with enhanced features like operator overloading, custom imports, and export handling.

### Signature

```typescript
function compile(
  code: string,
  globals?: Record<string, any>,
  options?: RunOptions
): CompiledCode
```

### Parameters

#### `code: string`
The JavaScript code to compile. This can include:
- Standard JavaScript syntax
- Export statements (when `options.returns` is "exports")
- Import statements (when `options.importFunction` is provided)
- Operator overloading expressions (when `options.operatorOverloading` is enabled)

#### `globals?: Record<string, any>` (optional)
An object containing variables and functions to make available in the code's execution scope. Only identifiers that are actually referenced in the code will be included in the final scope for security and performance.

**Default:** `{}`

#### `options?: RunOptions` (optional)
Configuration options for parsing, transforming, and executing the code.

**Default:** 
```typescript
{
  parseOptions: { ecmaVersion: "latest" },
  codegenOptions: {},
  returns: "exports",
  operatorOverloading: true,
  customVisitors: {},
  isAsync: false
}
```

**Properties:**

- **`parseOptions?: Partial<acorn.Options>`**
  
  Options passed to the Acorn parser. 
  
  **Default:**
  ```typescript
  {
    ecmaVersion: "latest",
    sourceType: "module", // when options.returns === "exports", or if import function is defined
    allowReturnOutsideFunction: true // when options.returns === "return"
  }
  ```

- **`codegenOptions?: escodegen.GenerateOptions`**
  
  Options passed to Escodegen for code generation from the transformed AST.

- **`returns?: "exports" | "return"`**
  
  Defines how the code should handle return values:
  - `"exports"` (default): Use export statements to return values, enables modular code patterns
  - `"return"`: Use standard JavaScript return statements
  
- **`operatorOverloading?: boolean`**
  
  Enables Python-like operator overloading via magic methods using the `Py` symbols.
  
  **Default:** `true`



- **`importFunction?: (source: string) => Object | Promise<Object>`**
  
  Custom import handler for resolving module imports. Can be synchronous or asynchronous.

- **`isAsync?: boolean`**
  
  Wraps the generated code in an async function, enabling top-level await usage.
  
  **Default:** `false`
  
  **Note:** Even with explicit `isAsync: false`, the function returned by compile will still return a promise (will be async) if:
  - Any `await` keyword appears in the code
  - Your code has import statements, and the passed importFunction is async
  
  **TODO:** Check for await keywords - they should affect the async behavior only if they are used on the root level, because if they are used internally in an async function defined in the code, they shouldn't change the compile function behavior.

### Return Value

Returns a `CompiledCode` object with the following properties:

```typescript
interface CompiledCode {
  origCode: string;    // The original input code
  genCode: string;     // The generated/transformed JavaScript code
  fn: Function;        // The compiled function ready for execution
  args: any[];         // The arguments array to pass to the function
  run: () => any;      // Convenience method to execute the compiled code
}
```

#### Properties

- **`origCode: string`** - The original input code passed to the compile function
- **`genCode: string`** - The transformed JavaScript code generated by eval-magic
- **`fn: Function`** - The compiled function ready for execution
- **`args: any[]`** - The array of arguments that will be passed to the function when executed
- **`run: () => any`** - A convenience method that executes the compiled function with the prepared arguments

## Usage Examples

### Basic Compilation

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `export const result = x + y;`,
  { x: 10, y: 20 }
);

console.log(compiled.origCode);  // `export const result = x + y;`
console.log(compiled.genCode);   // Generated JavaScript code
console.log(compiled.run());     // { result: 30 }
```

### Using Return Instead of Export

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `return x * 2;`,
  { x: 15 },
  { returns: "return" }
);

console.log(compiled.run()); // 30
```

### Working with Complex Expressions

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const doubled = x * 2;
  const squared = doubled ** 2;
  export const result = squared + offset;
  `,
  { x: 5, offset: 10 }
);

console.log(compiled.run()); // { result: 110 }
```

### Operator Overloading

```javascript
import { compile, Py } from "eval-magic";

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  [Py.__add__](other) {
    return new Point(this.x + other.x, this.y + other.y);
  }

  toString() {
    return `Point(${this.x}, ${this.y})`;
  }
}

const compiled = compile(
  `
  const p1 = new Point(1, 2);
  const p2 = new Point(3, 4);
  export const result = p1 + p2;
  `,
  { Point }
);

const result = compiled.run();
console.log(result.result.toString()); // Point(4, 6)
```

### Async Code with Top-Level Await

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
  await delay(100);
  export const result = "Async operation completed";
  `,
  { setTimeout: global.setTimeout },
  { isAsync: false } // This will be ignored because the code has await keyword
);

// Note: run() returns a Promise when the code contains await or isAsync is true
const result = await compiled.run();
console.log(result); // { result: "Async operation completed" }
```

### Advanced Configuration

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const helper = (x) => x * 2;
  export const computed = helper(data) ** 2;
  `,
  { data: 5 },
  {
    parseOptions: {
      ecmaVersion: 2020,
      sourceType: "module"
    },
    codegenOptions: {
      format: {
        indent: {
          style: "  "
        }
      }
    },
    returns: "exports",
    operatorOverloading: true,
    isAsync: false
  }
);

const result = compiled.run();
console.log(result); // { computed: 100 }
```

## Integration with `evaluate`

The `compile` function is used internally by the `evaluate` function. You can use `compile` when you need more control over the execution process or want to reuse the compiled code multiple times:

```javascript
import { compile, evaluate } from "eval-magic";

// Using evaluate (simple, one-time execution)
const result1 = evaluate(
  `export const sum = a + b;`,
  { a: 1, b: 2 }
);

// Using compile (more control, reusable)
const compiled = compile(
  `export const sum = a + b;`,
  { a: 1, b: 2 }
);

const result2 = compiled.run();
const result3 = compiled.run(); // Can reuse the compiled function

// Both approaches yield the same result
console.log(result1); // { sum: 3 }
console.log(result2); // { sum: 3 }
console.log(result3); // { sum: 3 }

// Assert that all results are equal
console.assert(JSON.stringify(result1) === JSON.stringify(result2));
console.assert(JSON.stringify(result2) === JSON.stringify(result3));
console.assert(JSON.stringify(result1) === JSON.stringify(result3));
```

## Error Handling

The `compile` function may throw errors during various phases:

### Parse Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(`invalid javascript syntax {`);
} catch (error) {
  console.error("Parse error:", error.message);
  // Handle syntax errors in the input code
}
```

### Transform Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(
    `import { unknown } from "missing-module";`,
    {},
    {
      importFunction: (source) => {
        throw new Error(`Module not found: ${source}`);
      }
    }
  );
  
  compiled.run();
} catch (error) {
  console.error("Import error:", error.message);
  // Will show: "Module not found: missing-module"
}
```

### Configuration Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(
    `export const result = x;`,
    { x: 42 },
    {
      parseOptions: {
        ecmaVersion: 3 // Very old version might cause issues
      }
    }
  );
} catch (error) {
  console.error("Configuration error:", error.message);
}
```

## Performance Considerations

- **Scope Filtering**: Only variables from `globals` that are actually referenced in the code are included in the execution scope
- **Reusability**: Compiled functions can be executed multiple times without recompilation
- **Async Overhead**: Setting `isAsync: true` adds async function wrapper overhead

```javascript
import { compile } from "eval-magic";

// Compile once, run multiple times for better performance
const compiled = compile(
  `export const result = input * 2;`,
  { input: 0 } // Placeholder, will be filtered out
);

// This is more efficient than calling evaluate() multiple times
const results = [1, 2, 3, 4, 5].map(num => {
  // Note: You'd need to modify the approach for different inputs
  // This example shows the concept of reusability
  return compiled.run();
});
```

For different inputs, you would typically use parameter passing or recompile with new globals as needed.

## Related Functions

- **[`evaluate`](README.md#usage)**: Higher-level function that compiles and immediately executes code
- **[`Py` operators](README.md#example)**: Magic method symbols for operator overloading

## TODOs

- [ ] Allow compiled functions to be called with different `globals` several times without the need to re-compile