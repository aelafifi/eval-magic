# API Documentation

## How Eval-Magic Works

Eval-Magic transforms and evaluates JavaScript code through a sophisticated multi-step process:

### 1. AST Parsing & Transformation
The input JavaScript code is parsed into an Abstract Syntax Tree (AST) using the Acorn parser. This allows eval-magic to analyze and transform the code structure before execution.

### 2. Operator Overloading
When enabled, operator expressions (like `+`, `-`, `*`, etc.) are rewritten to call special magic methods on objects. This enables Python-like operator overloading in JavaScript without language-level changes.

### 3. Custom Import Handling
Import statements can be processed by a user-defined function, allowing for custom module resolution, mocking, or dynamic imports that would otherwise be impossible in eval contexts.

### 4. Export Interception
Instead of using `return`, you can use `export` statements in your code snippets. Eval-magic intercepts these exports, making it easier to write modular code that doesn't interrupt natural code flow.

### 5. Scoped Execution
The transformed code is generated back to JavaScript and executed in a controlled scope. This scope is merged with the global scope when needed, providing both isolation and access to necessary globals.

## `compile` Function

The `compile` function is the core functionality of eval-magic that parses, transforms, and prepares JavaScript code for execution with enhanced features like operator overloading, custom imports, and export handling.

### Signature

```typescript
function compile(
  code: string,
  globals?: Record<string, any>,
  options?: RunOptions
): CompiledCode
```

### Parameters

#### `code: string`
The JavaScript code to compile. This can include:
- Standard JavaScript syntax
- Export statements (when `options.returns` is "exports")
- Import statements (when `options.importFunction` is provided)
- Operator overloading expressions (when `options.operatorOverloading` is enabled)

#### `globals?: Record<string, any>` (optional)
An object containing variables and functions to make available in the code's execution scope. Only identifiers that are actually referenced in the code will be included in the final scope for security and performance.

**Default:** `{}`

#### `options?: RunOptions` (optional)
Configuration options for parsing, transforming, and executing the code.

**Default:**
```typescript
{
  parseOptions: { ecmaVersion: "latest" },
  codegenOptions: {},
  returns: "exports",
  operatorOverloading: true,
  isAsync: false
}
```

**Properties:**

- **`parseOptions?: Partial<acorn.Options>`**
  
  Options passed to the Acorn parser. 
  
  **Default:**
  ```typescript
  {
    ecmaVersion: "latest",
    sourceType: "module", // when options.returns === "exports", or if import function is defined
    allowReturnOutsideFunction: true // when options.returns === "return"
  }
  ```

- **`codegenOptions?: escodegen.GenerateOptions`**
  
  Options passed to Escodegen for code generation from the transformed AST.

- **`returns?: "exports" | "return"`**
  
  Defines how the code should handle return values:
  - `"exports"` (default): Use export statements to return values, enables modular code patterns
  - `"return"`: Use standard JavaScript return statements
  
- **`operatorOverloading?: boolean`**
  
  Enables Python-like operator overloading via magic methods using the `Py` symbols.
  
  **Default:** `true`



- **`importFunction?: (source: string) => Object | Promise<Object>`**
  
  Custom import handler for resolving module imports. Can be synchronous or asynchronous.

- **`isAsync?: boolean`**
  
  Wraps the generated code in an async function, enabling top-level await usage.
  
  **Default:** `false`
  
  **Note:** Even with explicit `isAsync: false`, the function returned by compile will still return a promise (will be async) if:
  - Any `await` keyword appears in the code
  - Your code has import statements, and the passed importFunction is async

### Return Value

Returns a `CompiledCode` object with the following properties:

```typescript
interface CompiledCode {
  origCode: string;    // The original input code
  genCode: string;     // The generated/transformed JavaScript code
  fn: Function;        // The compiled function ready for execution
  args: any[];         // The arguments array to pass to the function
  run: () => any;      // Convenience method to execute the compiled code
}
```

#### Properties

- **`origCode: string`** - The original input code passed to the compile function
- **`genCode: string`** - The transformed JavaScript code generated by eval-magic
- **`fn: Function`** - The compiled function ready for execution
- **`args: any[]`** - The array of arguments that will be passed to the function when executed
- **`run: () => any`** - A convenience method that executes the compiled function with the prepared arguments

## Usage Examples

### Basic Compilation

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `export const result = x + y;`,
  { x: 10, y: 20 }
);

console.log(compiled.origCode);  // `export const result = x + y;`
console.log(compiled.genCode);   // Generated JavaScript code
console.log(compiled.run());     // { result: 30 }
```

### Using Return Instead of Export

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `return x * 2;`,
  { x: 15 },
  { returns: "return" }
);

console.log(compiled.run()); // 30
```

### Working with Complex Expressions

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const doubled = x * 2;
  const squared = doubled ** 2;
  export const result = squared + offset;
  `,
  { x: 5, offset: 10 }
);

console.log(compiled.run()); // { result: 110 }
```

### Operator Overloading

```javascript
import { compile, Py } from "eval-magic";

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  [Py.__add__](other) {
    return new Point(this.x + other.x, this.y + other.y);
  }

  toString() {
    return `Point(${this.x}, ${this.y})`;
  }
}

const compiled = compile(
  `
  const p1 = new Point(1, 2);
  const p2 = new Point(3, 4);
  export const result = p1 + p2;
  `,
  { Point }
);

const result = compiled.run();
console.log(result.result.toString()); // Point(4, 6)
```

### Async Code with Top-Level Await

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
  await delay(100);
  export const result = "Async operation completed";
  `,
  { setTimeout: global.setTimeout },
  { isAsync: false } // This will be ignored because the code has await keyword
);

// Note: run() returns a Promise when the code contains await or isAsync is true
const result = await compiled.run();
console.log(result); // { result: "Async operation completed" }
```

### Advanced Configuration

```javascript
import { compile } from "eval-magic";

const compiled = compile(
  `
  const helper = (x) => x * 2;
  export const computed = helper(data) ** 2;
  `,
  { data: 5 },
  {
    parseOptions: {
      ecmaVersion: 2020,
      sourceType: "module"
    },
    codegenOptions: {
      format: {
        indent: {
          style: "  "
        }
      }
    },
    returns: "exports",
    operatorOverloading: true,
    isAsync: false
  }
);

const result = compiled.run();
console.log(result); // { computed: 100 }
```

## Integration with `evaluate`

The `compile` function is used internally by the `evaluate` function. You can use `compile` when you need more control over the execution process or want to reuse the compiled code multiple times:

```javascript
import { compile, evaluate } from "eval-magic";

// Using evaluate (simple, one-time execution)
const result1 = evaluate(
  `export const sum = a + b;`,
  { a: 1, b: 2 }
);

// Using compile (more control, reusable)
const compiled = compile(
  `export const sum = a + b;`,
  { a: 1, b: 2 }
);

const result2 = compiled.run();
const result3 = compiled.run(); // Can reuse the compiled function

// Both approaches yield the same result
console.log(result1); // { sum: 3 }
console.log(result2); // { sum: 3 }
console.log(result3); // { sum: 3 }

// Assert that all results are equal
console.assert(JSON.stringify(result1) === JSON.stringify(result2));
console.assert(JSON.stringify(result2) === JSON.stringify(result3));
console.assert(JSON.stringify(result1) === JSON.stringify(result3));
```

## Error Handling

The `compile` function may throw errors during various phases:

### Parse Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(`invalid javascript syntax {`);
} catch (error) {
  console.error("Parse error:", error.message);
  // Handle syntax errors in the input code
}
```

### Transform Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(
    `import { unknown } from "missing-module";`,
    {},
    {
      importFunction: (source) => {
        throw new Error(`Module not found: ${source}`);
      }
    }
  );
  
  compiled.run();
} catch (error) {
  console.error("Import error:", error.message);
  // Will show: "Module not found: missing-module"
}
```

### Configuration Errors

```javascript
import { compile } from "eval-magic";

try {
  const compiled = compile(
    `export const result = x;`,
    { x: 42 },
    {
      parseOptions: {
        ecmaVersion: 3 // Very old version might cause issues
      }
    }
  );
} catch (error) {
  console.error("Configuration error:", error.message);
}
```

### Fallback Sequence For Binary Operators

1. Left operand's operator method (e.g., `left[Py.__add__]`)
2. Right operand's reverse operator method (e.g., `right[Py.__radd__]`)
3. Left operand's shorthand method (e.g., `left[Py.__arithmetic__]`)
4. Right operand's reverse shorthand method (e.g., `right[Py.__arithmetic__]`)
5. Default JavaScript behavior (e.g., `left + right`)

## Performance Considerations

- **Scope Filtering**: Only variables from `globals` that are actually referenced in the code are included in the execution scope
- **Reusability**: Compiled functions can be executed multiple times without recompilation
- **Async Overhead**: Setting `isAsync: true` adds async function wrapper overhead

```javascript
import { compile } from "eval-magic";

// Compile once, run multiple times for better performance
const compiled = compile(
  `export const result = input * 2;`,
  { input: 0 } // Placeholder, will be filtered out
);

// This is more efficient than calling evaluate() multiple times
const results = [1, 2, 3, 4, 5].map(num => {
  // Note: You'd need to modify the approach for different inputs
  // This example shows the concept of reusability
  return compiled.run();
});
```

For different inputs, you would typically use parameter passing or recompile with new globals as needed.

## `evaluate` Function

The `evaluate` function is a convenience wrapper around `compile` that immediately executes the compiled code and returns the result.

### Signature

```typescript
function evaluate(
  code: string,
  globals?: Record<string, any>,
  options?: RunOptions
): any
```

### Parameters

The parameters are identical to the `compile` function:

- **`code: string`** - The JavaScript code to evaluate
- **`globals?: Record<string, any>`** - Variables to make available in the execution scope
- **`options?: RunOptions`** - Configuration options for parsing and execution

### Return Value

Returns the direct result of executing the compiled code, which depends on the `options.returns` setting:

- When `returns: "exports"` (default): Returns an object containing all exported values
- When `returns: "return"`: Returns the value from the return statement

### Usage Examples

```javascript
import { evaluate } from "eval-magic";

// Basic evaluation with exports
const result = evaluate(
    `export const sum = x + y;
     export const product = x * y;`,
    { x: 5, y: 3 }
);
console.log(result); // { sum: 8, product: 15 }

// Using return instead of export
const value = evaluate(
    `return x + y;`,
    { x: 10, y: 20 },
    { returns: "return" }
);
console.log(value); // 30

// With custom imports
const result = await evaluate(
    `import { sqrt } from "math";
     export const root = sqrt(x);`,
    { x: 16 },
    {
        importFunction: async (moduleName) => {
            if (moduleName === "math") {
                return { sqrt: Math.sqrt };
            }
            throw new Error("Module not found: " + moduleName);
        }
    }
);
console.log(result); // { root: 4 }
```

### When to Use `evaluate` vs `compile`

- **Use `evaluate`** when you need to execute code once and get immediate results
- **Use `compile`** when you want to reuse the compiled code multiple times, inspect the generated code, or have more control over execution

## RunOptions Interface

The `RunOptions` interface provides comprehensive configuration for how eval-magic parses, transforms, and executes code.

```typescript
interface RunOptions {
  parseOptions?: Partial<acorn.Options>;
  codegenOptions?: escodegen.GenerateOptions;
  returns?: "exports" | "return";
  operatorOverloading?: boolean;
  importFunction?: (source: string) => Object | Promise<Object>;
  isAsync?: boolean;
}
```

### Properties

#### `parseOptions?: Partial<acorn.Options>`

Options passed to the Acorn parser for JavaScript parsing.

**Default:**
```javascript
{
  ecmaVersion: "latest",
  sourceType: "module", // when returns === "exports"
  allowReturnOutsideFunction: true // when returns === "return"
}
```

**Common Options:**
- `ecmaVersion`: JavaScript version (e.g., 2020, "latest")
- `sourceType`: "script" or "module"
- `allowReturnOutsideFunction`: Allow return statements at top level

#### `codegenOptions?: escodegen.GenerateOptions`

Options passed to Escodegen for code generation from the transformed AST.

**Example:**
```javascript
{
  format: {
    indent: {
      style: "  " // 2-space indentation
    },
    newline: "\n",
    space: " "
  }
}
```

#### `returns?: "exports" | "return"`

Defines how the code returns values:

- **`"exports"`** (default): Use export statements anywhere in code
- **`"return"`**: Use standard JavaScript return statements

#### `operatorOverloading?: boolean`

Enables Python-like operator overloading via magic methods.

**Default:** `true`

When enabled, operators like `+`, `-`, `*` are transformed to check for magic methods like `Py.__add__`, `Py.__sub__`, etc.

#### `importFunction?: (source: string) => Object | Promise<Object>`

Custom import handler for resolving import statements in the code.

**Parameters:**
- `source`: The module specifier string from the import statement

**Returns:** An object representing the module, or a Promise resolving to such an object

**Example:**
```javascript
importFunction: async (moduleName) => {
  switch (moduleName) {
    case "lodash":
      return await import("lodash");
    case "math":
      return { sqrt: Math.sqrt, pow: Math.pow };
    default:
      throw new Error(`Unknown module: ${moduleName}`);
  }
}
```

#### `isAsync?: boolean`

Wraps the code in an async function, enabling top-level await.

**Default:** `false`, but automatically set to `true` if `importFunction` is async

**Note:** This adds overhead even if no await is used, so only enable when necessary.

## Related Functions

- **[`Py` operators](./OPERATORS.md)**: Magic method symbols for operator overloading
